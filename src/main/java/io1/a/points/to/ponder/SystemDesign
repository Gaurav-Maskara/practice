 
 
-----------------------------------------------------------------------------------------------------------------------------------------------------
------Load Balancer ---------------------------------------------------------------------------------------------------------------------------------
 
 1.Load balancing : is how the load is being distributed among different servers:One of the ways for distributing the load 
   could be using the hashing techniques in which , depending on a particular field , say ID , and a particular hash function 
   and the no of servers ,server is decided where the request would land. (eg. hashFunction(ID) % no Of servers)
   
   This was an example of inconsistent hashing , bcs any addition of a new server , would make the request go to some other
   server ,because the value of generated hash would be different , this would result in dumping of all the caches 
   which were already stored on a particular server since for the same ID we would have the same hash value and hence the
   same server.
   
   To the Rescue of above issue is consistent Hashing : 
   
   Load balancing techniques --> Round Robin , Least Connection , Random
                                 # Least Connection method
                                 # Least response Time
                                 # Least Bandwidth Method: this method selects the server that is serving the least amount of traffic in terms of Mbps
                                 # Round Robin
                                 # Weighted Round Robin
                                 # ip Hash
   
   
   Two Types of Load balancers :
      Layer 4 : Works on Transport Layer and has access to TCP, UDP, IP, Port 
      Layer 7 : Application Layer , has access to everything layer 4 has. Additionally has access to HTTP headers, cookies, payload
      
      Note: Load balancer is a machine that acts as a reverse proxy , for each request it picks up a server based on its strategy.
            Load balancers make the system more scalable and resilient .
            

2. Reverse Proxy --> a reverse proxy is a type of proxy server where the servers return resources to the client 
                     where it would appear to the network that it originated from the reverse proxy server itself.
   
------Load Balancer ---------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------------------------------
------CDN -------------------------------------------------------------------------------------------------------------------------------------------

  1. CDN is comparatively very cheaper compared to keeping servers everywhere
  2. Used for keeping static content like --> 	images, html, css, javascript
  3. Types of CDN :
     Push : We need to push
     Pull : It pulls when a request arrives from a user but it doesn't have it and then sync itself
  4. In short --> it decreases costs, decreases latency, increases complexity of system
  5. If the system we are building isn't large enough to have its own CDN , we can ease a future transition by serving the static media off a separate 
     sub-domain(e.g. static.yourservice.com) using a lightweight HTTP server like NGINX , and cut-over the DNS from your servers to a CDN later.

-----CDN --------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------------------------------
----- CACHING ---------------------------------------------------------------------------------------------------------------------------------------
	1. Pros : improves read performance, reduce the load
	2. Cons : increases complexity , consumes resources
	
	3. Caching Strategies : 
	                      Cache Aside: App (is it in cache) if no then get data from DB(app will get the data and then stores it in cache for next time)
	                      Read through: App (asks cache is it in there) if Not cache will get the data, store it for next time and then send back the data
	                      Write Through: App (updates the cache) and then DB is updated
	                      Write behind:
    4. Eviction Policies : LRU and LFU
    5. LRU is faster and cheaper in terms of memory than LFU 
    6. Redis :(key value Store) supports around 100k+ requests per second on a single node
    7. Redis : Supports : string, list , set , hash
               No support for JSON or nested Data
               
    8.Caching: (Redis and Memcache can be used) : Access pattern or  caching strategies 
	    Cache Invalidation : (i.e. when we want to update any value , how caching works)
	   . Write through cache : Data is written in cache and database at the same time
	   . Write -around cache : Data is written in Db only . Cache is marked as invalid .It is written later in cache
	   . Write- back cache :   Data is written in cache only. It is written in Db later
	   Read heavy system : can use caching
	   Cache Eviction : LRU is the most used technique, next is LFU
	   
	9. Prod level machines can have ram of around : 72GB or 144Gb
	   
   9. @Value("${spring.redis.host}")
    private String REDIS_HOSTNAME;
   
    @Value("${spring.redis.port}")
    private int REDIS_PORT;                  // Setting up hostname and port for redis. Redis template in spring boot provides many methods

----- CACHING -------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------------------------------
----- QUEUEs --------------------------------------------------------------------------------------------------------------------------------------
 1. There are producers and consumers
 2. Common Queues: Kafka, Rabbit MQ, Amaxon SqS, Apache Active MQ
 3. Pros: Request Spikes smoothing, buffering
    Cons: Increases latency, increases system complexity
 4. Kafka is a distributed service. Should be deployed in multiple boxes. Queue can process 1 million but we need to think of consumer scaling
 
 5. Apache Kafka is: //Producer api push data to kafka using "spring boot kafka templates" using the topics. Consumer Api consume data from kafka topics
	    Scalable
	    Fault tolerant
	    A great publish-subscribe messaging system (using kafka topics)
	    Capable of higher throughput compared with most messaging systems
	    Highly durable
	    Highly reliable
	    High performant
 
 
--------------------------------------------------------------------------------------------------------------------------------------------------
----- QUEUEs -------------------------------------------------------------------------------------------------------------------------------------


--------------------------------------------------------------------------------------------------------------------------------------------------
----- TCP ----------------------------------------------------------------------------------------------------------------------------------------
  1. Some protocols that work under the hood of tcp : websockets, HTTP
     TCP : is reliable and error checked but slower . It adds a checksum for each packet sent
  2. UDP : Mostly used for : Monitoring metrics (like stocks where real time data is a priority), 
           Video streaming, Gamimg (where a small loss of data packet is not going to effect anything)
  3. Websockets : Connection is established only once. Real time message delivery to the client. Persistent connection.
                  More efficient than polling with HTTP. Two way protocol
  4. gRPC : Remote procedure call : Invoke another service as if it is a local function

----- TCP ----------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------------------------------------------------------
----- Concurrency Vs Parallelism -----------------------------------------------------------------------------------------------------------------
  1. Parallelism : Doing more than one thing at a time
  2. Concurrency : Providing an illusion of doing more than one thing at a time
  3. What type of data structure Index is (in SQL table) : B Tree Plus 

----- Concurrency Vs Parallelism ----------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------------------------------------------------
----- Sharding ----------------------------------------------------------------------------------------------------------------------------------
  1. What type of data structure Index is (in SQL table) : B Tree Plus 
  2. Tenanat based sahrding : data is not evenly distributed . For example india can have huge data as compared to israel(low population)
  3. Hash based sharding: 
  4. There can be locater service (shard router) between a app and sharded DB . whose task could be determine the DB in which data will go :
                   but the shard router may act as single point of failure. So this is not preferred
  5. Solution for Above Sharding issue : Consistent Hashing
  
  6. Sharding: (Other things : Horizontal Sharding , Vertical Sharding, Database partitioning )
	   Problems:
	   1. Joins across shards could be very expensive because the data will be pulled out from two db and then will travel over network
	      for a join
	   2. In sharded database there should always be master slave model. so that if master fails , slaves could take over
	      there could be multiple slaves which will be copying the master. Whenever there is a write request , its always 
	      on the master(the master is the most updated copy). While the slaves continuously poll the master and read from it.
	      If there is a read request it can distributed across slaves , while if there is write request, it always 
	      goes to the master.In case the master fails, the slaves choose one master among themselves.
	      (So, basically it provides single point of failure tolerance)

  7. MultiLevel sharding. Indexing in relational database internally uses B+ tree which gives O(log(n)) insertion and search operation
  8. Master Slave : Slave can pull data from master either synchronously or aync

----- Sharding -------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------------------------------------------
----- Partitioning ---------------------------------------------------------------------------------------------------------------------------------

  1. Sharding : is breaking a big DB into smaller DBs
  2. Partitioning : is breaking a Large table into smaller tables . So smaller tables means faster queries
                    smaller indexes can fit into memory
                    Cons : Joins may be required to fetch data
  3. Partition : can be achieved by depending on a key

----- Partitioning -----------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------------------------------------
----- CAP theorem ------------------------------------------------------------------------------------------------------------------------------------

	1. CAP theorem (Its quite a common question related to compromises around Relational and NoSql Databases) : Cap stands for -->consistency, availability and
	   partition tolerant. As per this theorem --> When network partition occurs , system cannot be both consistent and highly available    
	   Conflict Resolution after network is back to normal on CAP theorem :
	    --> Majority Based
	    --> Time stamp based
	    
	2. Consistency: All nodes in the cluster have consistent data and a read request returns the most recent write from any node.
	
	Note : Note that the consistency definitions in CAP Theorem and ACID Transactions are different. 
	       ACID consistency is about data integrity (data is consistent w.r.t. relations and constraints after every transaction). 
	       CAP is about the state of all nodes being consistent with each other at any given time.
	       
	       CAP Tradeoffs: SQL DBs prioritize consistency over everything else. 
	       But NoSQL datastores typically prioritize availability and partition tolerance (horizontal scale) and offer eventual consistency.

----- CAP theorem ------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------------------------------------
-----------ACID---------------------------------------------------------------------------------------------------------------------------------------

1.  ACID : Atomicity, Consistency, Isolation , Durability : A transaction is a single logical unit of work consisting of one or more instructions which accesses
    and possibly modifies the contents of a database.To maintain the integrity of the database each transaction should be ACID compliant.

    Atomicity : Either all the instructions will succeed or all will fail .
    Consisteny: DB should be in consistent state before and after the transaction , there should not be any corruption of data, or duplicates 
                shouldn't be allowed to be committed
    Isolation : If multiple transactions are running concurrently , then they should not be affected by each other
    Durability : Changes once committed should persist, even after hardware or software failure
    All financial transactions should follow ACID.
    
    Note : The main reason hash maps are not used for index and BTree is used bcs they have worse performance when finding a range of
           entries as compared to BTree
-----------ACID--------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------




------------------------------------------------------------------------------------------------------------------------------------------------------
-----------Difference between Horizontal and Vertical Scaling-----------------------------------------------------------------------------------------

1.Differences between Horizontal & Vertical Scaling :
  Horizontal: 
         	Load Balancing Required
         	Resilient
         	Network Calls (RPC) (to different services)
         	Data Inconsistency
         	Scales Well as new users are added
  Vertical:
  		   Load Balancing Not Required
  		   Single Point of Failure
  		   Inter process communication no RPC required
  		   Consistent
  		   Hardware Limit
  		   
-----------Difference between Horizontal and Vertical Scaling-----------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------


------------------------------------------------------------------------------------------------------------------------------------------------------
-----Monoliths and MicroServices ---------------------------------------------------------------------------------------------------------------------

 1.Distributed System:
 		   Micro Service architecture
 		   Distributed systems (Partitions)
 		   Load Balancer
 		   Decoupling
 		   Logging and Analytics
 		   Extensible
 		   
 		   
 2. Monolithic : 
   1. Suitable for small team
   2. Less Complex
   3. Integration testing is easier
   4. Faster since no network calls are made
   DisAdvantage:
	   1. New developer needs more context to go through everything and understand everything
	   2. Deployment is complex as whole code is deployed again
	   3. Too much responsibility on each server
   
   
	3. Microservices :
	   1.Easier to scale (as anything which is used more can be scaled easily)
	   2.Easier for new team members
	   3.Parallel development is easy because of loose coupling
	   Disadvantages:
         1.Tough to design

 4. 3 Guarantees of distributed systems which are required: Consistency, Availability, Partition tolerant   
 

-----Monoliths and MicroServices --------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------




-----Database ---------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------

1.Benefits of NoSql: Joins are expensive in relational databases. Schema is flexible in NoSql as all we care about is 
  json. Inbuilt horizontal partitioning in nosql DBs.
  DisAdvantages:
  1. Not good for loads of updates as consistency is problem since ACID is not guaranteed.
  2. Read is comparatively slower to RDBMS bcs its has to read the whole json to find and return particular sets
  3. Joins are hard bcs it will read all the json like manually and then will try to join the values
 So , Nosql is better for write optimized databases

2. Storage: 
    Object storage : example amazon s3 for storing images
    RAID : Redundant array of independent disks, is a way of storing data on multiple hard disks or sdd to protect in case of failures.RAID 5 is most used


3. Nosql db --> are more scable and provides higher performance with flexible datamodel unlike fixed tables in relational databases.
    4 main types : key-value (redis, voldemort), Column oriented(Cassandra), Document based (MongoDb), Graph Based (Neo4j)

4. SQL :When to consider: Lots of data management and BI tools rely on SQL. If you have a flat tabular data model that isn't going to change very often
        and doesnt't need to scale out.
        Those with a large ecosystem of SQL skills and tools and numerous existing applications may choose to continue using a relational data mode
        Cons: Postgres can support replication but more advanced features such as automatic failover must be supported by third party products.
              Whereas MongoDBâ€™s has in-built self-healing capabilities.
5. SQL : Can be preferred where we many small tables and very small data is required sometimes in fragment , unlike NoSql which stores all document
         in json format at one place

6. Read heavy : Reads are more efficient in MongoDB's storage engine
7. Write heavy : Cassandra (column oriented): It stores data in append only format, so serial writes are done very quickly.
                 Good for : heavy write workloads
                 Data distribution across multiple data centres and cloud availability zones i.e. is the users are far separated
                 Bad for : ACID. To achieve high availability cassandra sacrifices strong consistency. Bad for update(as stale data might get read up till it gets deleted)
                 Example : Analytics, Messaging Systems, Ecommerce
                 
   How to choose A Database :          
8. BASE : Like ACID in RDBMS: BASE is for Nosql : 
	          Basic Availability :Data is available for most of the times
	          Soft State : Replicas are not consistent all the time
	          Eventual Consistency : Data will become consistent in future , but no guarantee when
          The BASE system allow horizontal scaling , fault tolerance , and high availability at the cost of Consistency
          (So if the app requires high availability and scability , a NoSql DB built on Base properties would be suitable)
          
          
   NoSql : Semi Structured or Unstructured data/ Flexible schema
           No complex queries or stored procedures or views
           High velocity transactions
           Large volume of data (in Tb ranges)
           Requires distributed computing and storage
           No data warehouse , analytics or BI use case
           
   RDBMS : ACID transactions
           Complex queries or stored procedures or views
           Migration to another Db without change into application logic
           Data analytics , warehouse or BI use case


9. CA : Choose RDBMS
   CP : Redis (K:V), MongoDb (Doc store), HBase(Col Orineted)
   AP : Cassandra (Col oriented), Couchbase (Doc store)
   
   
   Choose K:V Stores if:
	    Simple schema
	    High velocity read/write with no frequent updates
	    High performance and scalability
	    No complex queries involving multiple keys or joins

   Choose Document Stores if:
	    Flexible schema with complex querying
	    JSON/BSON or XML data formats
	    Leverage complex Indexes (multikey, geospatial, full text search etc)
	    High performance and balanced R:W ratio

   Choose Column-Oriented Database if: (its a 2D versioned key value)
	    High volume of data
	    Extreme write speeds with relatively less velocity reads
	    Data extractions by columns using row keys
	    No ad-hoc query patterns, complex indices or high level of aggregations
	    
   Choose Graph Database if:
	    Applications requiring traversal between data points
	    Ability to store properties of each data point as well as relationship between them
	    Complex queries to determine relationships between data points
	    Need to detect patterns between data points
	    
 10. Link : https://towardsdatascience.com/datastore-choices-sql-vs-nosql-database-ebec24d56106 (see the cheat sheet at the end)
 
 11. Highly available : For this we can have Multi Master instead of just having Master Slave architecture

-----Database ---------------------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------



-----Architecture Patterns and Questionns -----------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------

1.Single Tier Application -- Presentation, Business, Data Access Layer in a single software package. Eg. MP3 player, MS Office
2.Two Tier Application -- Client Application & Database (client system sends the request and the server system processes the request and sends back to client)
3.Three Tier Application (Aka web based app) --
4.N-Tier -- Distributed Application
5. Trade offs in Microservice Architecture :
   # Availability
   # Performance
   # Consistency
   # Speed
   # Composability
   # Compute
   # Scability
   # Marginality
   # Partition Tolerance
   
6. Ajax Polling : It means it sends a request to the server in a defined interval of time. The problem with this approach is it would cause a lot of useless
                  requests since there would not be response for every request
7. Ajax Long Polling : It means that the client sends a request to the server and the server waits for the new data to be available before it responds


8. How can the server keep track of all the opened connection to redirect messages to the users efficiently? 
	    The server can maintain a hash table, where key would be the UserID and the value would      
		be the connection object. So whenever the server receives a message for a user, it looks up that user in
		the hash table to find the connection object and sends the message on the open request.
		
9. How many chat servers we need? 
   Lets plan for 500 million connections at any time. 
	Assuming a modern server can handle 50K concurrent connections at any time, we would need 10K such servers.
	
10. How the chat server can maintain an ordering of the message ?
    # there could be two ways possible for it ..first to use the time stamp but it can have issues
    # second we can use the sequence numbers to determine the ordering of the messages


11. FB Messenger --> HBase (CP is required with huge data and small updates)
    url shortening --> Cassandra
    PasteBin --> Metadata (sql), S3(for object storage)
    Instagram --> SQL(Metadata), S3 (for images/objects)
    Twitter --> memcache(since it can store the whole tweet object)
    Youtube/Netflix --> Each uploaded video will be pushed to a processing queue to be de-queued later for encoding, thumbnail generation and storage
                        Video Metadata --> MySql
                        Popular videso can be moved to CDN
    TypeHead Suggestion --> Since we have to suggest in minimun latency ..we cannot store data in some database . We need to store our indexes in memory
                            in a highly efficient data structure
                            Data Structure --> Trie
    
    
    
    
12. Read Requests 
    Write Requests
    Read Data 
    Write Data
    Caching / PerDay
    Data / 5 years
    DB Type & Object Storage


1. Trie data structure for Google search
2. Map DS for url shortner







# Amazon: 
FR --> Search , cart/wish list / checkout / view orders
NFR --> Low latency, High Availability, High Consistency


# Twitter :
FR --> Post tweets, see timeline, follow other users , Tweet can contain photos and videos
NFR --> Highly available , low latency(200 ms is accepted for timeline generation), consistency can take a hit if user doesn't see a tweet for some time
Extended Requirements --> Searching tweets, Replying tweets, trending topics, tweet notification, Who to follow suggestion






-----Architecture Patterns and Questionns -----------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------------------------------



1. Can you name some metrics for measuring system performance?
Ans : The three most common metrics used to measure a system's performance are availability, latency and throughput. These metrics help 
      system designers measure the speed of a user's experience while interacting with a system. Availability 
      shows us how often a system responds to a user in a ratio of Uptime vs. Downtime. Latency refers to the speed at which a message is 
      delivered in milliseconds. Finally, throughput measures the amount of data that successfully travels through a system to a user in a 
      specified time period. Throughput is typically calculated in bits per second.
      
      
2. how can you improve the performance of a DB 
Ans : By dividing the table into multiple tables as using a common table to have loads of data . Which causes problems since our table gonna have huge 
      amount of data that could make read/write operations pretty slow bs MySql generally does linear search if data is not indexed.
      
      By minimising if there are so many tables bcs it could make the queries a little faster , but not in every case bcs we are having lots of 
      table which means have to apply joins while retrieving data that could make the queries a little slower and complex too , not to forget
      the management issues.
      
3. Let’s decide how many table your database should roughly have
Ans : There is very simple approach to roughly decide, how many tables you should have is to total number of unique entity your application gonna have
      Number of tables could be more than that too while normalizing the database schema  
      # of table = # of unique entities your application have
      
4. When to divide the table into multiple tables and why?
Ans : Whenever you feel that you’re gonna have redundant values in any of your column that directly indicates that your design is 
      not good enough and you should separate that column from the current table so that it won’t have redundant values.

      Whenever you feel that you’re gonna have null in some any of your column then again it directly indicates that your database schema is not good 
      enough because any column should not contain null values whatever may happen, but based on your use case if you 
      are getting null values in some your rows then you should separate that column to a new table.
      (https://medium.com/swlh/basic-guide-to-design-a-better-database-schema-83fda45aba1c)
      
5. What are the different types of constraints ?
Ans : Unique, null values, foreign keys, composite key or check constraint

6. Difference between primary and foreign key ?
Ans : primary key helps to uniquely identify a record in the table. Foreign key is the primary key of another table
      primary --> cannot be null. Foreign Key --> can be null
      primary --> by default clustered index . Foreign --> Nothing by default . But index can be created
      primary --> there could be only a single primary key. Foreign --> there could be multiple foreign keys


7. Schema design 
Ans : List out all the features . then identify the entities supporting the features


8. How to scale the Databases ?
Ans : #First identify the bottleneck using metrics at what time or cause caused this issue.
      #Check logs that take longer time to load or there could be third party apis or the DB server could be introducing the delays
      #You identify that your database is probably heavily normalized, so you introduce some redundant columns (these columns frequently appear in WHERE
            or JOIN ON clause in queries) in highly used tables for the sake of denormalization.
            
      #Increasing the connection pool , as opening a new connection takes time (application server creates the connection pool)
      #Database indexing: it improves the speed of data retrieval operation from the table
      #Caching the DB queries (usually an application will have a handful of queries that make up the majority of the requests)
           : This helps as load is distributed to cache and and DB is free. also it increases the availability 
      #Vertical scaling   
      #Master-Slave : writing to master(cloned to slave). Reading from slave DB
      #Partitioning : by functionality so that a particular system can be scaled and the result can be aggregated in the backend application
                      (i.e. microservices architecture)
      #Horizontal Scaling: All machines have the same set of tables (sharding) , and have their own replicas which can be used in case of failure.
      #There is still slowness in some of the countries : distributing traffic in different data centres around the globe(also helps in disaster recovery)
     
      #Moving session data to some cache instead of stroing them into table
       (https://www.keycdn.com/blog/database-performance)
 		   
 		   

   
 



   		


 
 
 
 12. Relational Database Design :
 

 

   


   
16. Consistent Hashing: read something about it


   


   

    

22. Architectural patterns : Monolithic, SOA, Microservice
    Difference between SOA and Microservice : Read ??

    
24. Back of the Envelope Calculations :Estimate how many servers we need to serve read requests considering each server is capable of handling 
    7 requests per second. We have to serve a total traffic of 46 Million per day.
    Answer: 
    7 requests per second
    7*60 = 420 requests per minute
    420*60 requests per hour = 400 * 60 = 24000 per hour = 24K per hour
    24K * 24 requests per day â‰ˆ 30K*20 = 600K requests per day per server
    We want to handle 46 Million requests per day which means 46M/600K = approx 45M/500K = 45M/0.5M = 45*2 = 90 servers.
    
25. Note : Highly Available systems : Follow the no single point of failure principle
    Note : Systems with high performance : Follow the no bottleneck principle


27. Purging: Purging is the process of freeing up space in the database or of deleting obsolete data that is not required by the system
    A server which runs the purging job can be used to purge the Database



29. Having an index on a particular field makes searching easier in DB on the other hand writing expensive

30. See the micro services design patterns and write something about it : Like Saga pattern ---> in this pattern
    "so some cron jobs will fix those status inconsistencies" if there is a failure cron job will make sure to maintain consistencies


32. Read replicas for mongodb or postgreSQL











   
   
   