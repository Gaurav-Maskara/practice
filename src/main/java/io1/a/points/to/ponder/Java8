
1. Only Lists and Sets support new methods stream() and parallelStream()
2. Parallel streams are capable of operating on multiple threads
3. hm.forEach((i, j) -> System.out.println(i+" "+j)); ---> hm is hash map
4. A functional interface in Java is an interface that contains only a single abstract (unimplemented) method
5. Since in java8 interfaces can have default and static methods , to avoid diamond problem, its necessary 
   that the implementing class should override the method , if two interfaces have the same name default methods

6. Since functional interfaces have only one method, lambda expressions can easily provide the method implementation. 
   We just need to provide method arguments and business logic
   
   Runnable r = new Runnable(){
            @Override
            public void run() {
                System.out.println("My Runnable");
            }};

    Runnable r1 = () -> {
            System.out.println("My Runnable");
    };
    
7. Lambda expressions are a means to create anonymous classes of functional interfaces easily.

8. Improvements in the java Date and Time Api :
   Why was it needed :
   --> earlier Date classes are mutable, so they are not thread-safe.
   --> earlier Date class doesn't provide internationalization, there is no time zone support. 
      
   Improvements :
   -->Immutability
   --> Separation of Concerns: 
       The new API separates clearly between human-readable date time and machine time (Unix timestamp).
   --> Utility operations: All the new Date-Time API classes come with methods to perform common tasks, 
       such as plus, minus, format, parsing, getting the separate part in date/time, etc.
   --> LocalDate ld = LocalDate.now(); --> example
   --> LocalDate todayKolkata = LocalDate.now(ZoneId.of("Asia/Kolkata"));
   --> LocalTime is an immutable class whose instance represents a time in the human readable format. 
       Its default format is hh:mm:ss.zzz. Just like LocalDate, this class provides time zone support 
       and creating instance by passing hour, minute and second as input arguments.
   --> LocalDateTime today = LocalDateTime.now(); // 
   --> Instant class is used to work with machine readable time format. Instant stores date time in unix timestamp.
       Instant timestamp = Instant.now();
       
9. If the interface is annotated with @FunctionalInterface annotation and 
   we try to have more than one abstract method, it throws compiler error.
   
10.Java 8 Collections API has been rewritten and new Stream API is introduced that uses a lot of functional interfaces. 
   Java 8 has defined a lot of functional interfaces in java.util.function package. 
   Some of the useful java 8 functional interfaces are Consumer, Supplier, Function and Predicate

11.To check if a number is prime using Java 8
   return number > 1 && IntStream.range(2, number).noneMatch(index -> number % index == 0);
   Refer : https://www.journaldev.com/2763/java-8-functional-interfaces

12. For Lamda and streams : For one line method bodies you can skip both the braces {} and the return keyword

13. Functional interface must contain exactly one abstract method declaration. 
    Since default methods are not abstract you're free to add default methods to your functional interface.
    
14.The JDK 1.8 API contains many built-in functional interfaces. Some of them are well known from
   older versions of Java like Comparator or Runnable. 
   Those existing interfaces are extended to enable Lambda support via the @FunctionalInterface annotation

15.Predicate ## ==> Predicates are boolean-valued functions of one argument
   eg:  Predicate<String> predicate = (s) -> s.length() > 0;
		predicate.test("foo");              // true
		predicate.negate().test("foo");     // false

   eg:  Predicate<String> pr = (s) -> {
			if(s!=null && s.length() > 3) {
				return s.contains("a");
			}
			return false;
		};
		
	    System.out.println(pr.test("pa"));
	    System.out.println(pr.test("pppa"));


16. Functions# Functions accept one argument and produce a result.
    eg: 	Function<String, Integer> f = s -> Integer.valueOf(s);
	        System.out.println(f.apply("123"));
	        
17. Comparator<Person> comparator = (p1, p2) -> p1.firstName.compareTo(p2.firstName);

18. Optionals are not functional interfaces, instead it's a nifty utility to prevent NullPointerException. 
    Optional is a simple container for a value which may be null or non-null. 
    Think of a method which may return a non-null result but sometimes return nothing. 
    Instead of returning null you return an Optional in Java 8.
    Optional<String> optional = Optional.of("bam");

	optional.isPresent();           //  true
	optional.get();                 // "bam"
	optional.orElse("fallback");    // "bam"
	
	optional.ifPresent((s) -> System.out.println(s.charAt(0)));     // "b"
	
19. Streams : java.util.Stream represents a sequence of elements on which one or more operations can be performed.
    Stream operations are either intermediate or terminal.
    Note : MAPS are NOT supported
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
-----------------------------------------------------------------------------------------------------------------
SQL: 

1. Self Join Syntax: 
    SELECT column-names
      FROM table-name T1 JOIN table-name T2
    WHERE condition
    
Question : Match customers that are from
           the same city and country 
           
           
    SELECT B.FirstName AS FirstName1, B.LastName AS LastName1, 
           A.FirstName AS FirstName2, A.LastName AS LastName2, 
           B.City, B.Country
      FROM Customer A JOIN Customer B
        ON A.Id <> B.Id
       AND A.City = B.City 
       AND A.Country = B.Country
     ORDER BY A.Country
     
     
2. SQL Subquery Example :
   
   Problem: List products with order
   quantities greater than 100. 
    
    SELECT ProductName
    FROM Product 
    WHERE Id IN (SELECT ProductId 
                    FROM OrderItem
                   WHERE Quantity > 100)
    
    
    
3. Question :List the top 10 most expensive products ordered by price 
    
    SELECT TOP 10 Id, ProductName, UnitPrice, Package
    FROM Product
    ORDER BY UnitPrice DESC
    
    
4. SELECT COUNT (DISTINCT Country)
   FROM Supplier;
   
5. 	hm.forEach((k, v) -> System.out.println(k +v)); //iterate over map in java 8 using lambdas
    map.entrySet().stream().forEach(e -> System.out.println(e.getKey() + ":" + e.getValue()));
    
6. 
    
    
    
    
    
    
    
    
    




