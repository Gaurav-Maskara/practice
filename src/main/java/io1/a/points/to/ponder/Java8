

-----------------------Java 8 features ---------------------------------------------------------------------------------------------------------------------

1. Only Lists and Sets support new methods stream() and parallelStream()
2. Parallel streams are capable of operating on multiple threads
3. hm.forEach((i, j) -> System.out.println(i+" "+j)); ---> hm is hash map
4. A functional interface in Java is an interface that contains only a single abstract (unimplemented) method
5. Since in java8 interfaces can have default and static methods , to avoid diamond problem, its necessary 
   that the implementing class should override the method , if two interfaces have the same name default methods

6. Since functional interfaces have only one method, lambda expressions can easily provide the method implementation. 
   We just need to provide method arguments and business logic
   
   Runnable r = new Runnable(){
            @Override
            public void run() {
                System.out.println("My Runnable");
            }};

    Runnable r1 = () -> {
            System.out.println("My Runnable");
    };
    
7. Lambda expressions are a means to create anonymous classes of functional interfaces easily.

8. Improvements in the java Date and Time Api :
   Why was it needed :
   --> earlier Date classes are mutable, so they are not thread-safe.
   --> earlier Date class doesn't provide internationalization, there is no time zone support. 
      
   Improvements :
   --> Immutability
   --> Separation of Concerns: 
       The new API separates clearly between human-readable date time and machine time (Unix timestamp).
   --> Utility operations: All the new Date-Time API classes come with methods to perform common tasks, 
       such as plus, minus, format, parsing, getting the separate part in date/time, etc.
   --> LocalDate ld = LocalDate.now(); --> example
   --> LocalDate todayKolkata = LocalDate.now(ZoneId.of("Asia/Kolkata"));
   --> LocalTime is an immutable class whose instance represents a time in the human readable format. 
       Its default format is hh:mm:ss.zzz. Just like LocalDate, this class provides time zone support 
       and creating instance by passing hour, minute and second as input arguments.
   --> LocalDateTime today = LocalDateTime.now(); // 
   --> Instant class is used to work with machine readable time format. Instant stores date time in unix timestamp.
       Instant timestamp = Instant.now();
       
9. If the interface is annotated with @FunctionalInterface annotation and 
   we try to have more than one abstract method, it throws compiler error.
   
10.Java 8 Collections API has been rewritten and new Stream API is introduced that uses a lot of functional interfaces. 
   Java 8 has defined a lot of functional interfaces in java.util.function package. 
   Some of the useful java 8 functional interfaces are Consumer, Supplier, Function and Predicate

	Function: To transform arguments in returnable value.
	Predicate: To perform a test and return a Boolean value.
	Consumer: Accept arguments but do not return any values.
	Supplier: Do not accept any arguments but return a value. 
	Operator: Perform a reduction type operation that accepts the same input types.
   
   

11.To check if a number is prime using Java 8
   return number > 1 && IntStream.range(2, number).noneMatch(index -> number % index == 0);
   Refer : https://www.journaldev.com/2763/java-8-functional-interfaces

12. For Lambda and streams : For one line method bodies you can skip both the braces {} and the return keyword

13. Functional interface must contain exactly one abstract method declaration. 
    Since default methods are not abstract you're free to add default methods to your functional interface.
    
14.The JDK 1.8 API contains many built-in functional interfaces. Some of them are well known from
   older versions of Java like Comparator or Runnable. 
   Those existing interfaces are extended to enable Lambda support via the @FunctionalInterface annotation

15.Predicate ## ==> Predicates are boolean-valued functions of one argument
   eg:  Predicate<String> predicate = (s) -> s.length() > 0;
		predicate.test("foo");              // true
		predicate.negate().test("foo");     // false

   eg:  Predicate<String> pr = (s) -> {
			if(s!=null && s.length() > 3) {
				return s.contains("a");
			}
			return false;
		};
		
	    System.out.println(pr.test("pa"));
	    System.out.println(pr.test("pppa"));


16. Functions# Functions accept one argument and produce a result.
    eg: 	Function<String, Integer> f = s -> Integer.valueOf(s);
	        System.out.println(f.apply("123"));
	        
17. Comparator<Person> comparator = (p1, p2) -> p1.firstName.compareTo(p2.firstName);

18. Optionals are not functional interfaces, instead it's a nifty utility to prevent NullPointerException. 
    Optional is a simple container for a value which may be null or non-null. 
    Think of a method which may return a non-null result but sometimes return nothing. 
    Instead of returning null you return an Optional in Java 8.
    Optional<String> optional = Optional.of("bam");

	optional.isPresent();           //  true
	optional.get();                 // "bam"
	optional.orElse("fallback");    // "bam"
	
	optional.ifPresent((s) -> System.out.println(s.charAt(0)));     // "b"
	
	
	//Above way can throw null pointer in case the value is null
	//However the below method will not throw a Null Pointer , even if the value is null
	    String test = "this can be null";
		Optional<String> opt = Optional.ofNullable(test);
		String finalValue = opt.isPresent() ? opt.get():opt.orElse("some other value");
		
	//Another way 
	String name = Optional.ofNullable(nullName).orElse("john");
	
	//
	Integer year = 2016;
    Optional<Integer> yearOptional = Optional.of(year);
    boolean is2016 = yearOptional.filter(y -> y == 2016).isPresent();
	
	
19. Streams : java.util.Stream represents a sequence of elements on which one or more operations can be performed.
    Stream operations are either intermediate or terminal.
    Note : MAPS are NOT supported
    
20. Regex -->
    
20. Java Memory management ---> 
    Heap Memory is divided into --> Young Generation and Old Generation
                                    Young Generation is divided into --> Eden Memory & Survivor Memory
    
    Permanent Generation (Perm Gen) --> It is not a part of Heap Memory
          !! Perm Gen !! : MetaData information of classes was stored in PremGen (Permanent-Generation) memory type before Java 8. 
    Metadata is what is also known as annotations in Spring when a class or 
    method is declared and annotated it adds metadata (configuration data) to the class. Some Spring annotations are @Autowired, @Component, @Controller
    Since Java 8 PermGen has been removed with MetaSpace due to its inefficiency of having a fixed size resulting in OutOfMemory Error
    MetaSpace grows automatically by default
    
    
    
    
    ()-> According to the Merriam Webster dictionary, "metadata" means "data that provides information about other data".
    In Java, class metadata provides information about a given class, such as:
		    What annotations does it have?
		    What constructors does it have?
		    What methods does it have?
		    What fields does it have?
		    What interfaces does it implement?
		    Is it public, private, or default (package) scoped?
		    Is it abstract? Is it final? Is it static?
		    What package does it belong to?
		    
    MetaSpace: Java 8 stores the MetaData of classes in native memory called 'MetaSpace'. 
    It is not a contiguous Heap Memory and hence can be grown dynamically which helps to overcome the size constraints. 
    This improves the garbage collection, auto-tuning, and de-allocation of metadata.
    
    
21. Inner class --> Static and Normal Inner class . Their behavior is similar to static and normal methods.
    The advantage is it could be either public , protected , default or private unlike outer class which could either be public 
    or default.  In inner class we can hide data and expose the outer class.
    Also , if particular fields are only associated with outer class, making inner class is preferable
    

    
22. Immutable class --> Make all the fields as private and final. There should not be any setter methods.
    Class should be declared final . Perfrom deep cloning(eg. if there is hash map)
    Should a return a clone of the object whenever asked for. 
    
    
-------Design Patterns---------------------------------------------------------------------------------------------------------------------------------------
    
23. Design patterns : Creational , Structural , Behavioral
    
    Creational--> Factory --> define an interface or abstract class for creating an object but let the subclasses decide which class to instantiate
                  Abstract Factory -->
                  Prototype --> cloning of an existing object instead of creating new one
                                This pattern should be followed, if the cost of creating a new object is expensive and resource intensive
                  Object Pool -->  Object pool is a container which contains a specified amount of objects
    
    Structural --> 
    
    Behavioral --> Chain of Responsibility Pattern : If one object cannot handle the request then it passes the same to the next receiver and so on.
                   Template pattern --> just define the skeleton of a function in an operation, deferring some steps to its subclasses
                                        It is very common technique for reusing the code.This is only the main benefit of it.
    
-------Design Patterns---------------------------------------------------------------------------------------------------------------------------------------
 


-------Streams-----------------------------------------------------------------------------------------------------------------------------------------------

24.Map<String, Long> count =  al.stream().collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
                              al.stream().map(a -> a.toUpperCase()).collect(Collectors.toList());
                              al.stream().filter(a -> a.startsWith("abc")).filter(a -> a.endsWith("cc")).collect(Collectors.toList());
	                          al.stream().filter(a -> a.startsWith("r")).forEach(a -> System.out.println(a + " "));
                              Map<Integer, Integer> map = al.stream().collect(Collectors.toMap(a -> a, a -> a*a));
                              
                              
                              
26. Iterating Over Map In Java 8 :
	    --> for(Entry<String, String> entry : map.entrySet()) {
	        	System.out.println(entry.getKey() + " " + entry.getValue());
	        }
	        
	    --> map.forEach((k, v) -> System.out.println(k + " " + v));
	    
	    --> map.entrySet().stream().forEach( e -> System.out.println(e.getKey() + " " + e.getValue()));
	    

                              
26. Iterating Over Map In Java 8 :
	    --> for(Entry<String, String> entry : map.entrySet()) {
	        	System.out.println(entry.getKey() + " " + entry.getValue());
	        }
	        
	    --> map.forEach((k, v) -> System.out.println(k + " " + v));
	    
	    --> map.entrySet().stream().forEach( e -> System.out.println(e.getKey() + " " + e.getValue()));
	    

-------Streams-----------------------------------------------------------------------------------------------------------------------------------------------
 


-------Concurrency ------------------------------------------------------------------------------------------------------------------------------------------


25. Locks : 
     private ReentrantReadWriteLock  lock = new ReentrantReadWriteLock();
     lock.writeLock().lock();
     lock.writeLock().unlock();
       
     private ReentrantLock lock = new ReentrantLock();
     lock.lock();
     lock.unlock();	
       
  ThreadLocal<Integer> threadLocalCounter = new ThreadLocal<Integer>();
  threadLocalCounter.set(threadLocalCounter.get().intValue() + 1);     
  
     private static AtomicReference<String> atomicReference = new AtomicReference<String>("Hello Ji");
     
     BlockingQueue<Integer> queue = new ArrayBlockingQueue<Integer>(10);
       
       
       
26. ConcurrentHashMap --> Multiple threads basically 32 in nature (since its divided into 32 buckets at start) can work on it concurrently.
                          A particular section out of the 32 buckets is locked during a read write operation
                          
    CopyOnWriteArrayList --> For each update operation a cloned copy of the same is created which is later synchronized by the JVM.
                             Since cloning is costly , its preferred mostly on read heavy
                             Its iterator (eithe iterator or listiterator) cannot perform a remove operation and will throw UnsupportedOperationException
                             It won't throw however , ConcurrentModificationException
       
-------Concurrency ------------------------------------------------------------------------------------------------------------------------------------------








 
    
-----------------------------------------------------------------------------------------------------------------
SQL: 

1.  Self Join Syntax: 
    SELECT column-names
      FROM table-name T1 JOIN table-name T2
    WHERE condition
    
Question : Match customers that are from
           the same city and country 
           
           
    SELECT B.FirstName AS FirstName1, B.LastName AS LastName1, 
           A.FirstName AS FirstName2, A.LastName AS LastName2, 
           B.City, B.Country
    FROM Customer A JOIN Customer B
        ON A.Id <> B.Id
        AND A.City = B.City 
        AND A.Country = B.Country
     ORDER BY A.Country
     
     
2. SQL Subquery Example :
   
   Problem: List products with order
   quantities greater than 100. 
    
    SELECT ProductName
    FROM Product 
    WHERE Id IN (SELECT ProductId 
                    FROM OrderItem
                   WHERE Quantity > 100)
    
    
    
3. Question :List the top 10 most expensive products ordered by price 
    
    SELECT TOP 10 Id, ProductName, UnitPrice, Package
    FROM Product
    ORDER BY UnitPrice DESC
    
    
4. SELECT COUNT (DISTINCT Country)
   FROM Supplier;
   
5. 	hm.forEach((k, v) -> System.out.println(k +v)); //iterate over map in java 8 using lambdas
    map.entrySet().stream().forEach(e -> System.out.println(e.getKey() + ":" + e.getValue()));
    
6. 
    
    
    
    
    
    
    
    
    




