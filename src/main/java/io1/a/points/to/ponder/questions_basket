
1. How to sort data that can’t fit into main memory?
Ans: User external sorting where data is sorted in chunks and merged back to get the sorted result (External merge sorted is used here)

2. Name some garbage collection algos in java
Ans: 


3. Define factory design pattern
Ans: It says just define the interface or abstract class to decide the way of instantation and initiation

4. Different approaches for creating a singleton clas 
Ans : Eager initialization , static block initialization, lazy initialization, thread safe singleton, thread safe singleton using double check
Note : in eager initialization there is wastage of cpu if object is not required moreover exception handling can't be done
       but exception handling can be done in static block
       
5. How can the singleton pattern be destroyed ?
Ans: 1. By Reflection
     2. By Serialization
     3. By Cloning
     
     1.Prevention from reflection : use enum singleton
     2.From Serialization : override read resolve method in singleton class to return the same object
                          eg. in method --> protected Object readResolve(){ return getInstance()};
     3.From cloning : 
                    When singleton class implements cloneable interface 
                    Ans:Overide the clone method and either return the same object or throw clonenot supported exception
                    When the singleton class doen't implement the cloneable interface but extends a class, which has implemented the cloneable interface
                    Ans : The solution for this would be same as above


6. Cloning ?
Ans: The class should implement the cloneable interface , also it should override the clone method
     #Shallow copy cloning : in clone method return : return super.clone();
     #Deep copy cloning : In this the primitive values as well as object references are also copied to the clone object
                          Do below in clone method:
                               Employee cloned = (Employee)super.clone();
                               cloned.setDepartment((Department)cloned.getDepartment().clone());   
                               return cloned;
                               
                               
7. What are the possible exception in serialization and deserialization ?
Ans: IOException/ FileNotFound/ ClassNotFound/ InvalidClass

8. What is serial version uid ?
Ans: In serialization process , an Id is associated with each serilizable class to verify the object at both sender and receiver side, this id is serial ver uid

9. Define or state effect of different keywords on serialization?
Ans: Final variables: serialized
     transient : not serialized 
     static : not serialized and has the current value of static variable in class memory
     Constructor of class is never called
     If the parent class has implemented the serializable interface then child class can be serialized but vice versa is not true
     
     
10. Enums can be used in place of public static final variables 
    Its a class basically used to declare constants
    
11. What is the difference between get and load methods of hibernate ?
Ans: Both of these methods are same as both are used to fetch the data from the DB
     Differences:
                Get: hits the Db and returns the object if the object is in DB 
                     returns null if the object is not in DB
                     loads the data as soon as method is called
                Load : It throws object not found if the object is not in the DB
     
     
12. What do you mean by persistence context ?
Ans: Loading of object in persistence context means that the object is 
     
13. What is the difference between ClassNotFound and NoClassDefFound exception ?
Ans : 1.ClassNotFound: Its a checked exception which is thrown when the JVM tries to load a class using Class.forName() or ClassLoader.className()
                     method but could not find the class at the class path
      2.NoClassDefFound: Its a Runtime exception which is thrown when JVM tries to load a class which was present at compile time & not found
                       at run time. 
      3.InvalidClassException: Its a Runtime exception thrown during deserilization when the serial ver uid of the class not matches with that of
                              class descriptor read from the stream
      4. UnsupportedClassVersionError: This occurs when a class is compiled using higher version JDK and is run on a lower version JDK


14. How to enable second level cache in your project ?
Ans: To configure the second level cache there are various cache providers such as EHCache
     1. add the dependencies
     2. enable second level caching in configuration file 
     
     
15. JVM architecture ?
Ans : 

16. Memory areas allocated by JVM ?
Ans: There are 5 memory areas allocated:
     1. Class (Method) area: this memory area stores the class level data of each class file(.class)
                             it contains data such as metadata, static variables
                             Note: There is only one class area per JVM shared by all classes
     2 

17. Memory areas allocated by JVM ?
Ans: there are 5 memeory areas allocated by JVM -
     1. Class (method) Area :this memory area stores the class level data of each class file(.class) . It contains data such as metadata, contant runtime pool
                             static variables , code for methods 
                             Note : There is only one class area per jvm shared by all the classes
     2. Heap Space : Its the memoey space where all the objects are created 
                     Note: there is only one heap space per jvm shared by all the threads
     3. Stack Memroy : In this memroy area all the local variables , local primitive variable, references to objects are created , stack frame per thread
                       Once thread is executed, the stack frame is also destroyed
                       Note: its thread safe since one stack frame is shared by only one thread
    
     4. PC(Program Counter) Register Area:This area holds the memory address of the JVM instructions which are currently being executed
                       Note:Each thread has its own pc area
     5. Native Method stack: Every method has its own native area where then native method data is stored
     
     
     
18. Class.for name can also be used for creating objects juts like new operator , refer the below example 
Ans: Test obj = (Test)Class.forName("Test").newInstance();

19. This keyword refers to the isnstance of the current class

20. Aggregation : has-a-relationship : eg Admin has invenory manager
21. Composition : has-a-relationship : Man has a car

22. Return type of the overriding method should be the same or the subclass of the return type of the parent class method
23. Interface can have private methods too since Java 9
24. String class implements 3 intefaces --> Serializable, Comparable, CharSequence

25. String constant pool is the memory area in heap memory where all the string literals are placed
26. By default toString prints the hashcode value of the object

27. Exception is thrown from the top of the stack for handling and then it percolates down till it is handled

28. Exception in Inheritance -->
    # When parent class method doesn't declare any exception then child class method cannot declare any checked exception
        but can declare unchecked exception
    #When parent class declares any exception then the child class method can declare same or sub class exception of parent class exception
       or not declare any exception
        

29. Note : error can also be thrown but not caught as the catch block only caught exception

30. Collection framework , collection is an interface, Collections is a utility class
    Collection framework: provides an architecture to store and manipulate group of objects
    collection interface declares then method that needs to be implemented
    
31. Iterator interface facilitates the functionality of iterating the elements in forward direction only
32. LinkedList in java is internally doubly linked list. Also in hashmap the values in buckets are stored as a chain of doubly linked list

33.HashSet internally uses HashMap for storing the values
   LinkedHashSet internally uses LinkedHashMap for storing the values. LinkedhashSet contains tow keys i.e. before and after which are used to 
                 maintain the insertion order
                 
34. Note**: TreeSet cannot contain null values as it is used by treemap to determine its location , which is not possible in case of null values
            Also , priority queue and treemap cannot store null keys as they have to maintain the insertion order
            
            
35. ArrayList is fail fast in nature which means concurrent operations are not allowed on it
    Note : inside the add method of arraylist , there is a check (ensureCapacity()) which checks if the size of the arraylist list is lesser than the 
           currently occupied , if its not it grows in size by 150% . the old data is copied (using clone) into a new array since the underlying data structure
           in a arraylist is array only
    
36. Fail fast iterator: The iterators which does not allow modification while iterating over it are known as fail fast iterators
    It throws concurrent modification exception     
    Eg: Iterators returned by ArrayList, Vector, Hashmap, HashSet 
    
    Fail Safe iterator: the iterators which allow the modification of collection while iterating over it are called fail safe iterator
    Eg: CopyOnWriteArrayList, ConcurrentHashMap

    Difference between both of them:
    Fail Fast :*Opposite of below
               *Uses original collection for traversing
               *Doesn't require extra memory
               *Fast
    
    
    Fail Safe: *Allows concurrent modification by other threads or process and doesn't throw concurrent modification exception
               *A deep copy of the original collection is used to traverse over the elements
               *It requires extra memory for cloning the collection
               *Slower as compared to fail fast
               
37. How is it determined , if there is any modification in collection ?
    Any modification is determined by comparing the modcount variable of the collection. Its a counter which gets incremented each time there is
    some modification like addition or removal


38. Context switching in threads take lesser time as compared to multi processes
    If any exception occurs in one thread , it doesn't affect other threads
    
39. Thread Scheduler is part of JVm which decides which thread should run
    There is no guarantee that which thread will be choosen to run by thread scheduler among all the runnable threads
    
40. can we start a thread twice ?
Ans: No. it will give Illegal Thread state exception

41. Default threads in Java..what are they ?
Ans: As java provides built in support for multithreading there are various threads which are created and started when a Java program startes
     EG: main thread --> it has various other threads created or define by the user
         daemon thread --> garbage collector, finalizer
         
42. How to create a deadlock in the main method ?
Ans Use this statement --> Thread.currentThread().join();


43. Daemon threads ?
Ans: These are service provider threads with almost least priority . These threads provide service to the other user thread and their life depends
     on mercy of user threads
     
44. Join method ?
Ans: It causes the currently running task to stop executing until the thread it joins completes its task or timed out

45. Yield Method ?
Ans: yield method of thread class causes the currently executing thread object to pause temporarily and allow other threads to execute
     Note : This method notifies the thread scheduler that this thread is not doing anything particularly important and if there are any 
            other threads which needs to run then they should run
     Note: If there are no other threads with a higher priority to run, then the current thread continues to run
     
46. Suspend method ?(Deprecated) As they may lead to deadlock
Ans: This method puts the invoking thread to waiting state until the same thread is resumed using the resume method

47. Resume method ? (Deprecated) As they may lead to deadlock
Ans: This method resumes the execution of invoking thread which is in suspended state.

48. Stop method ? (Deprecated) As they may lead to deadlock
Ans: this method is used to stop the execution of the running thread
     How deadlock can be caused: if a thread holds a lock on an object and thread is suspended . Now another thread will wait to hold the lock of that object 
     until the previous thread is resumed. in case previous thread doesn't resume, it may lead to deadlock
     
     
49. Thread Pool why ?
Ans: In a web application , there are various requests made from multiple clients. There are two approaches to cater to this request. 
     (i)- Create a thread for each request
     (ii) - Create a pool of threads with some fix no of threads to cater few requests at a time and the remaining requests goes into a queue.
     
     In former approach , Server will spend more time and more resources to create a thread every time for a new request.
     While, in the later approach a pool with a specific no of threads is created to cater to the requirement. If no thread is available
     to take the task , then the task remains in queue and executes as soon as a thread become available.

50. What is a thread pool ?
Ans: A thread pool is a group of worker threads which are previously created and are available to execute the tasks and can be used 
     multiple times till there is no thread leakage or thread pool is shutdown
     
     
51. Garbage collection is done automatically in java by daemon thread

52. What is unreachable or unreferenced object ?
Ans: As we know that when a object is created, then it is assigned the memory in heap area. The call stack has just the reference to this object along with 
     local variables. However when the object loses its reference , then in this case , object becomes unreachable .
     
53. Finalize method ?
Ans: Every class has its own finalize method . When an object is destroyed by garbage collector then finalize method of that class is called.

54. Difference between:
  
    Wait: Non static
          of object class
          release the lock 
          called on object
          resume by notify
   
   
   Sleep: Static
          of thread class
          don't release the lock
          called on current thread
          
          
   Yield: Static method
          of thread class
          don't release the lock
          
          
   Join: non static
         of thread class
         dont't release the lock
         called by thread which needs to execute first
         resume after task compeletes or timeout
         
   Suspend:non-static
           of thread class
           don't release the lock
           called by thread which needs to stop
           resume by resume method
           
           
55. What is monolithic architecture ?
Ans: The application architecture in which application has a single code base with multiple modules like product module, shipping module , user module
     This architecture mostly uses a single database
     
56. Microservices Architecture ?
Ans: In this various small services are made to work together to serve as a bigger or enterprise application
     Different microservices communicate to each each other through light weight protocol like HTTP. 
     It can be seen as decoupling of modules to work together
     Modules are loosely coupled
     
     
57. By default embedded tomcat or spring boot application doesn't support JSP. for adding jsp support we need to add jasper dependencies in pom.xml
    then we add prefix and suffix in application.properties
    spring.mvc.view.suffix=.jsp
    spring.mvc.view.prefix=/pages/
    
58. How many types of respositories are there for DB operations ?
Ans: CrudRespository : basic crud operations
     PagingAndSortingRepository : it extends the CrudRespository and allows the user to sort and paginate the results
     JpaRepository : It extends the PagingAndSortingRepository and adds JPA specific featues like flush();
     
     Example: Let student is the class which is mapped to student table and the roll no is the integer type which is the ID or primary key 
     Basic crud operations would be availabe in the interface that extends CrudRespository etc.
     
     Note: Since in real application we might need some complex queries, other than basic queries , so it will be done by below two steps
           (i): Create possible custom methods which are provided by spring .By default mostly operations are performed over id/primary key
                but we can customize them by just declaring abstract methods in the dao interface.
                eg. List<Student> findByStudentName(String name);
           (ii):Using JPQL/HQL: in case there are not available methods as per your requirement,then we can write queries as well just above
                our abstract method
                eg. Query("From Student where name = ? order by rollNumber")
                    List<Student> findByNameSorted(String name);
     
59. H2 database , add its dependency. localhost:8092/h2-console

60. @RestController = @Controller + @ResponseBody

61. @RequestMapping(path = "/addStudent", method = RequestMethod.POST)
    
    
    
    
62. What is the difference between request param and path variable ?
Ans: *request param --- values after ? in key value format--> /home/home.jsp?id=10&name= gaurav
     url will work with or without the request params.
     Receiving at server side by using @RequestParam annotation
     eg: @Getmapping("/home/home.jsp")
         public String getHome(@RequestParam ("id") int id)

     *path varibale --- /home/10/gaurav/home.jsp
      urls will not work as the path params form the path of the variable itself
      Receiving at server side by using the @PathVariable annotation 
      eg: @GetMapping("/home/{id}/{name}/home.jsp")
          public String getHome(@PathVariable ("id") int id, @PathVariable ("name") String name)
          
63. Difference between SOAP and REST
Ans: SOAP: XML only
           Its a protocol
           SOAP cannot use rest because its a protocol
           SOAP defines standards to be strictly followed
           SOAP requires more bandwidth
           SOAP defines its own security
           SOAP services uses xml over https or MQ, it requires a wsdl file to describe the payload for XML messages


     REST: Different data formats such as text, html, json,xml
           its a architectural style
           REST can use soap since its a concept and can use any protocol like HTTP, SOAP
           REST doesn't define much standards like SOAP
           REST requires less bandwidth
           RESTful webservices inherits security measures from the uderlying transport
           REST mostly uses http
           
           
64. @Bean annotation ?
Ans: By having a @Bean annotation over a method , we will have only one instance of the object that we create
      @Bean -- returns singleton object

65.  













































3. Third party garbage collectors
4. PermGen space (where classes are stored) is 64MB on Sun JVMs.
5. metaspace in java 8
6. Using a solution like AppDynamics you can easily monitor the different memory pool sizes over time to understand just 
   how close your application is exhausting memory so you can better finetune your JVM/CLR memory settings.
   
7.  I see two options, each of them having their pros and cons:
    Install a profiler agent and connect a profiler on your application. This has of course some serious performance impact which may be not acceptable in your production environment. But this would allow you to monitor the application and perform a memory dump when Heap space is almost full.
    Reproduce your production environment elsewhere and also use a profiler. If your issues only appear with big loads, you may have to create load tests so that you reach the OOME.
    Using a profiler is your best chance to find memory leaks.
    Otherwise, you can always try to perform static code reviewing, using PMD and Findbugs (amongst other static analysis tools) which may spot some mistakes.

   
8. For spring boot profiling : During application start we define the environment


