------------------------------------------------------------------------------------------------------------------------------------------------------------

1. How to sort data that can’t fit into main memory?
Ans: User external sorting where data is sorted in chunks and merged back to get the sorted result (External merge sorted is used here)

------------------------------------------------------------------------------------------------------------------------------------------------------------
2. Name some garbage collection algos in java
Ans: https://howtodoinjava.com/java/garbage-collection/all-garbage-collection-algorithms/
     1. Mark and sweep: scans the memory map and then deletes and then compaction is done
     2. Concurrent Mark and Sweep : multiple threads do the above process> this is an improvement since the stop the world even time is minimized due to 
                                    multiple threads doing the same work thereby improving the overall performance
                                    To use CMS GC, use below JVM argument: -XX:+UseConcMarkSweepGC
                                    Note: there are multiple options that we can use with CMS for its triggering when we require it like
                                          Trigger ratio percentage, No of threads for GC, parallel threads, 
     3. Serial Garbage Collection : It works on a single thread and uses : (preferred for small programs)
                                    mark-sweep --> for new generation
                                    mark-sweep-compact ---> old generation
     4. Parallel garbage collection : Similar to Serial GC, it uses
                                     mark-sweep --> for new generation
                                     mark-sweep-compact ---> old generation
                                     Multiple concurrent threads are used for marking and copying / compacting phases
                                     Parallel Garbage Collector is suitable on multi-core machines
     5.G1                           :Designed to be the replacement of CMS .it is parallel , concurrent, and incrementally compacting
                                    * This approach divides the memory area into multiple small regions . Each region is marked as either 
                                     young generation (further divided into eden and survivor) and old generation. This allows the G1 to approach the 
                                     problem incrementally
     
     Note: Till java 8, parallel GC was default algorithm.
     Note: Since java 9, G1 has been set as default GC algorithm.                         
------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                                      
3. Define factory design pattern
Ans: define an interface or abstract class for creating an object but let the subclasses decide which class to instantiate. 

MVC, Singleton(@Bean) (To share common data across all tiers we had used the singleton pattern. ), 
Template (jdbc template), chain of responsibility

------------------------------------------------------------------------------------------------------------------------------------------------------------

4. Different approaches for creating a singleton clas 
Ans : Eager initialization , static block initialization, lazy initialization, thread safe singleton, thread safe singleton using double check
Note : in eager initialization there is wastage of cpu if object is not required moreover exception handling can't be done
       but exception handling can be done in static block
       
5. How can the singleton pattern be destroyed ?
Ans: 1. By Reflection
     2. By Serialization
     3. By Cloning
     
     1.Prevention from reflection : use enum singleton
     2.From Serialization : override read resolve method in singleton class to return the same object
                          eg. in method --> protected Object readResolve(){ return getInstance()};
     3.From cloning : 
                    When singleton class implements cloneable interface 
                    Ans:Overide the clone method and either return the same object or throw clone not supported exception
                    When the singleton class doen't implement the cloneable interface but extends a class, which has implemented the cloneable interface
                    Ans : The solution for this would be same as above

------------------------------------------------------------------------------------------------------------------------------------------------------------

6. Cloning ?
Ans: The class should implement the cloneable interface , also it should override the clone method
     #Shallow copy cloning : in clone method return : return super.clone();
     #Deep copy cloning : In this the primitive values as well as object references are also copied to the clone object
                          Do below in clone method:
                               Employee cloned = (Employee)super.clone();
                               cloned.setDepartment((Department)cloned.getDepartment().clone());   
                               return cloned;
                             
------------------------------------------------------------------------------------------------------------------------------------------------------------
7. What are the possible exception in serialization and deserialization ?
Ans: IOException/ FileNotFound/ ClassNotFound/ InvalidClass
------------------------------------------------------------------------------------------------------------------------------------------------------------

8. What is serial version uid ?
Ans: In serialization process , an Id is associated with each serializable class to verify the object at both sender and receiver side, this id is serial ver uid

------------------------------------------------------------------------------------------------------------------------------------------------------------

9. Define or state effect of different keywords on serialization?
Ans: Final variables: serialized
     transient : not serialized 
     static : not serialized and has the current value of static variable in class memory
     Constructor of class is never called
     If the parent class has implemented the serializable interface then child class can be serialized but vice versa is not true
     
------------------------------------------------------------------------------------------------------------------------------------------------------------
     
10. Enums can be used in place of public static final variables 
    Its a class basically used to declare constants
    
------------------------------------------------------------------------------------------------------------------------------------------------------------
   
11. What is the difference between get and load methods of hibernate ?
Ans: Both of these methods are same as both are used to fetch the data from the DB
     Differences:
                Get: hits the Db and returns the object if the object is in DB 
                     returns null if the object is not in DB
                     loads the data as soon as method is called
                Load : It throws object not found if the object is not in the DB

------------------------------------------------------------------------------------------------------------------------------------------------------------
    
12. What do you mean by persistence context ?
Ans: The persistence context is the first-level cache where all the entities are fetched from the database or saved to the database
     Persistence context keeps track of any changes made into a managed entity. 
     If anything changes during a transaction, then the entity is marked as dirty. When the transaction completes, 
     these changes are flushed into persistent storage. 
     
     
Note: The EntityManager is the interface that lets us interact with the persistence context. 
      Whenever we use the EntityManager, we are actually interacting with the persistence context.

------------------------------------------------------------------------------------------------------------------------------------------------------------
     
13. What is the difference between ClassNotFound and NoClassDefFound exception ?
Ans : 1.ClassNotFound: Its a checked exception which is thrown when the JVM tries to load a class using Class.forName() or ClassLoader.className()
                       method but could not find the class at the class path
      2.NoClassDefFound: Its a Runtime exception which is thrown when JVM tries to load a class which was present at compile time & not found
                         at run time. 
      3.InvalidClassException: Its a Runtime exception thrown during deserilization when the serial ver uid of the class not matches with that of
                               class descriptor read from the stream
      4.UnsupportedClassVersionError: This occurs when a class is compiled using higher version JDK and is run on a lower version JDK

------------------------------------------------------------------------------------------------------------------------------------------------------------

14. How to enable second level cache in your project ?
Ans: To configure the second level cache there are various cache providers such as EHCache
     1. add the dependencies
     2. enable second level caching in configuration file 
     
------------------------------------------------------------------------------------------------------------------------------------------------------------

15. JVM architecture ?
Ans : 

------------------------------------------------------------------------------------------------------------------------------------------------------------

17. Memory areas allocated by JVM ?
Ans: there are 5 memory areas allocated by JVM -
     1. Class (method) Area :this memory area stores the class level data of each class file(.class) . It contains data such as metadata, contant runtime pool
                             static variables , code for methods 
                             Note : There is only one class area per jvm shared by all the classes
     2. Heap Space : Its the memory space where all the objects are created 
                     Note: there is only one heap space per jvm shared by all the threads
     3. Stack Memory : In this memory area all the local variables , local primitive variable, references to objects are created , stack frame per thread
                       Once thread is executed, the stack frame is also destroyed
                       Note: its thread safe since one stack frame is shared by only one thread
    
     4. PC(Program Counter) Register Area:This area holds the memory address of the JVM instructions which are currently being executed
                            Note:Each thread has its own pc area
     5. Native Method stack: Every method has its own native area where then native method data is stored
     
------------------------------------------------------------------------------------------------------------------------------------------------------------
     
18. Class.for name can also be used for creating objects juts like new operator , refer the below example 
Ans: Test obj = (Test)Class.forName("Test").newInstance();

By using cloning, by using serialization 
------------------------------------------------------------------------------------------------------------------------------------------------------------

19. This keyword refers to the instance of the current class

------------------------------------------------------------------------------------------------------------------------------------------------------------

20. Aggregation : has-a-relationship : eg. Admin has inventory manager
21. Composition : has-a-relationship : Man has a car

------------------------------------------------------------------------------------------------------------------------------------------------------------

22. Return type of the overriding method should be the same or the subclass of the return type of the parent class method

------------------------------------------------------------------------------------------------------------------------------------------------------------

23. Interface can have private methods too since Java 9

------------------------------------------------------------------------------------------------------------------------------------------------------------

24. String class implements 3 interfaces --> Serializable, Comparable, CharSequence

------------------------------------------------------------------------------------------------------------------------------------------------------------

25. String constant pool is the memory area in heap memory where all the string literals are placed
26. By default toString prints the hashcode value of the object

27. Exception is thrown from the top of the stack for handling and then it percolates down till it is handled

28. Exception in Inheritance -->
    # When parent class method doesn't declare any exception then child class method cannot declare any checked exception
        but can declare unchecked exception
    #When parent class declares any exception then the child class method can declare same or sub class exception of parent class exception
       or not declare any exception
        
29. Note : error can also be thrown but not caught as the catch block only caught exception

------------------------------------------------------------------------------------------------------------------------------------------------------------

30. Collection framework , collection is the root interface of the framework, Collections is a utility class which contains various static utility methods
    Collection framework: provides an architecture to store and manipulate group of objects
    collection interface declares that method that needs to be implemented
    
------------------------------------------------------------------------------------------------------------------------------------------------------------

31. Iterator interface facilitates the functionality of iterating the elements in forward direction only

------------------------------------------------------------------------------------------------------------------------------------------------------------

32. LinkedList in java is internally doubly linked list. Also in hashmap the values in buckets are stored as a chain of doubly linked list

------------------------------------------------------------------------------------------------------------------------------------------------------------

33.HashSet internally uses HashMap for storing the values
   LinkedHashSet internally uses LinkedHashMap for storing the values. LinkedhashSet contains two keys i.e. before and after which are used to 
                 maintain the insertion order
                 
------------------------------------------------------------------------------------------------------------------------------------------------------------
                 
34. Note**: TreeSet cannot contain null values as it is used by treemap to determine its location , which is not possible in case of null values
            Also , priority queue and treemap cannot store null keys as they have to maintain the insertion order
            
------------------------------------------------------------------------------------------------------------------------------------------------------------
            
35. ArrayList is fail fast in nature which means concurrent operations are not allowed on it
    Note : inside the add method of arraylist , there is a check (ensureCapacity()) which checks if the size of the arraylist list is lesser than the 
           currently occupied , if its not it grows in size by 150% . the old data is copied (using clone) into a new array since the underlying data structure
           in a arraylist is array only
           
------------------------------------------------------------------------------------------------------------------------------------------------------------
    
36. Fail fast iterator: The iterators which does not allow modification while iterating over it are known as fail fast iterators
    It throws concurrent modification exception     
    Eg: Iterators returned by ArrayList, Vector, Hashmap, HashSet 
    
    Fail Safe iterator: the iterators which allow the modification of collection while iterating over it are called fail safe iterator
    Eg: CopyOnWriteArrayList, ConcurrentHashMap

    Difference between both of them:
    Fail Fast :*Opposite of below
               *Uses original collection for traversing
               *Doesn't require extra memory
               *Fast
    
    
    Fail Safe: *Allows concurrent modification by other threads or process and doesn't throw concurrent modification exception
               *A deep copy of the original collection is used to traverse over the elements
               *It requires extra memory for cloning the collection
               *Slower as compared to fail fast
               
------------------------------------------------------------------------------------------------------------------------------------------------------------

               
37. How is it determined , if there is any modification in collection ?
Ans:Any modification is determined by comparing the modcount variable of the collection. Its a counter which gets incremented each time there is
    some modification like addition or removal

------------------------------------------------------------------------------------------------------------------------------------------------------------

38. Context switching in threads take lesser time as compared to multi processes
    If any exception occurs in one thread , it doesn't affect other threads
    
------------------------------------------------------------------------------------------------------------------------------------------------------------
    
39. Thread Scheduler is part of JVm which decides which thread should run
    There is no guarantee that which thread will be choosen to run by thread scheduler among all the runnable threads
    
------------------------------------------------------------------------------------------------------------------------------------------------------------
    
40. can we start a thread twice ?
Ans: No. it will give Illegal Thread state exception

------------------------------------------------------------------------------------------------------------------------------------------------------------

41. Default threads in Java..what are they ?
Ans: As java provides built in support for multithreading there are various threads which are created and started when a Java program startes
     EG: main thread --> it has various other threads created or define by the user
         daemon thread --> garbage collector, finalizer
------------------------------------------------------------------------------------------------------------------------------------------------------------

42. How to create a deadlock in the main method ?
Ans Use this statement --> Thread.currentThread().join();

------------------------------------------------------------------------------------------------------------------------------------------------------------


43. Daemon threads ?
Ans: These are service provider threads with almost least priority . These threads provide service to the other user thread and their life depends
     on mercy of user threads
     
------------------------------------------------------------------------------------------------------------------------------------------------------------
     
44. Join method ?
Ans: It causes the currently running task to stop executing until the thread it joins completes its task or timed out

------------------------------------------------------------------------------------------------------------------------------------------------------------

45. Yield Method ?
Ans: yield method of thread class causes the currently executing thread object to pause temporarily and allow other threads to execute
     Note : This method notifies the thread scheduler that this thread is not doing anything particularly important and if there are any 
            other threads which needs to run then they should run
     Note: If there are no other threads with a higher priority to run, then the current thread continues to run
     
------------------------------------------------------------------------------------------------------------------------------------------------------------
 
     
46. Suspend method ?(Deprecated) As they may lead to deadlock
Ans: This method puts the invoking thread to waiting state until the same thread is resumed using the resume method

47. Resume method ? (Deprecated) As they may lead to deadlock
Ans: This method resumes the execution of invoking thread which is in suspended state.

48. Stop method ? (Deprecated) As they may lead to deadlock
Ans: this method is used to stop the execution of the running thread
     How deadlock can be caused: if a thread holds a lock on an object and thread is suspended . Now another thread will wait to hold the lock of that object 
     until the previous thread is resumed. in case previous thread doesn't resume, it may lead to deadlock
     
------------------------------------------------------------------------------------------------------------------------------------------------------------


49. Thread Pool why ?
Ans: In a web application , there are various requests made from multiple clients. There are two approaches to cater to this request. 
     (i)- Create a thread for each request
     (ii) - Create a pool of threads with some fix no of threads to cater few requests at a time and the remaining requests goes into a queue.
     
     In former approach , Server will spend more time and more resources to create a thread every time for a new request.
     While, in the later approach a pool with a specific no of threads is created to cater to the requirement. If no thread is available
     to take the task , then the task remains in queue and executes as soon as a thread become available.

------------------------------------------------------------------------------------------------------------------------------------------------------------

50. What is a thread pool ?
Ans: A thread pool is a group of worker threads which are previously created and are available to execute the tasks and can be used 
     multiple times till there is no thread leakage or thread pool is shutdown
     
------------------------------------------------------------------------------------------------------------------------------------------------------------
     
51. Garbage collection is done automatically in java by daemon thread

------------------------------------------------------------------------------------------------------------------------------------------------------------

52. What is unreachable or unreferenced object ?
Ans: As we know that when a object is created, then it is assigned the memory in heap area. The call stack has just the reference to this object along with 
     local variables. However when the object loses its reference , then in this case , object becomes unreachable .
     
------------------------------------------------------------------------------------------------------------------------------------------------------------
     
53. Finalize method ?
Ans: Every class has its own finalize method . When an object is destroyed by garbage collector then finalize method of that class is called.

------------------------------------------------------------------------------------------------------------------------------------------------------------


54. Difference between:
  
    Wait: Non static
          of object class
         -->>> release the lock 
          called on object
          resume by notify
   
   
   Sleep: Static
          of thread class
          don't release the lock
          called on current thread
          
          
   Yield: Static method
          of thread class
          don't release the lock
          
          
   Join: non static
         of thread class
         dont't release the lock
         called by thread which needs to execute first
         resume after task compeletes or timeout
         
   Suspend:non-static
           of thread class
           don't release the lock
           called by thread which needs to stop
           resume by resume method
           
           
------------------------------------------------------------------------------------------------------------------------------------------------------------
           
55. What is monolithic architecture ?
Ans: The application architecture in which application has a single code base with multiple modules like product module, shipping module , user module
     This architecture mostly uses a single database
     
------------------------------------------------------------------------------------------------------------------------------------------------------------
     
56. Microservices Architecture ?
Ans: In this various small services are made to work together to serve as a bigger or enterprise application
     Different microservices communicate to each each other through light weight protocol like HTTP. 
     It can be seen as decoupling of modules to work together
     Modules are loosely coupled

------------------------------------------------------------------------------------------------------------------------------------------------------------
     
57. By default embedded tomcat or spring boot application doesn't support JSP. for adding jsp support we need to add jasper dependencies in pom.xml
    then we add prefix and suffix in application.properties
    spring.mvc.view.suffix=.jsp
    spring.mvc.view.prefix=/pages/
    
------------------------------------------------------------------------------------------------------------------------------------------------------------
    
58. How many types of respositories are there for DB operations ?
Ans: CrudRespository : basic crud operations
     PagingAndSortingRepository : it extends the CrudRespository and allows the user to sort and paginate the results
     JpaRepository : It extends the PagingAndSortingRepository and adds JPA specific featues like flush();
 
------------------------------------------------------------------------------------------------------------------------------------------------------------
    
     Example: Let student is the class which is mapped to student table and the roll no is the integer type which is the ID or primary key 
     Basic crud operations would be available in the interface that extends CrudRespository etc.
     
     Note: Since in real application we might need some complex queries, other than basic queries , so it will be done by below two steps
           (i): Create possible custom methods which are provided by spring .By default mostly operations are performed over id/primary key
                but we can customize them by just declaring abstract methods in the dao interface.
                eg. List<Student> findByStudentName(String name);
           (ii):Using JPQL/HQL: in case there are not available methods as per your requirement,then we can write queries as well just above
                our abstract method
                eg. Query("From Student where name = ? order by rollNumber")
                    List<Student> findByNameSorted(String name);
                    
------------------------------------------------------------------------------------------------------------------------------------------------------------
 
59. H2 database , add its dependency. localhost:8092/h2-console

60. @RestController = @Controller + @ResponseBody

61. @RequestMapping(path = "/addStudent", method = RequestMethod.POST)
   
------------------------------------------------------------------------------------------------------------------------------------------------------------
    
62. What is the difference between request param and path variable ?
Ans: *request param --- values after ? in key value format--> /home/home.jsp?id=10&name=gaurav
     url will work with or without the request params.
     Receiving at server side by using @RequestParam annotation
     eg: @Getmapping("/home/home.jsp")
         public String getHome(@RequestParam ("id") int id)

     *path varibale --- /home/10/gaurav/home.jsp
      urls will not work as the path params form the path of the variable itself
      Receiving at server side by using the @PathVariable annotation 
      eg: @GetMapping("/home/{id}/{name}/home.jsp")
          public String getHome(@PathVariable ("id") int id, @PathVariable ("name") String name)
          
------------------------------------------------------------------------------------------------------------------------------------------------------------
          
63. Difference between SOAP and REST
Ans: SOAP: XML only
           Its a protocol
           SOAP cannot use rest because its a protocol
           SOAP defines standards to be strictly followed
           SOAP requires more bandwidth
           SOAP defines its own security
           SOAP services uses xml over https or MQ, it requires a wsdl file to describe the payload for XML messages


     REST: Different data formats such as text, html, json,xml
           its a architectural style
           REST can use soap since its a concept and can use any protocol like HTTP, SOAP
           REST doesn't define much standards like SOAP
           REST requires less bandwidth
           RESTful webservices inherits security measures from the uderlying transport
           REST mostly uses http
           
------------------------------------------------------------------------------------------------------------------------------------------------------------

64. @Bean annotation ?
Ans: By having a @Bean annotation over a method , we will have only one instance of the object that we create
      @Bean -- returns singleton object
      
------------------------------------------------------------------------------------------------------------------------------------------------------------

65.  In Spring cloud we have the Eureka Server which is the client side discovery server ?
Ans : For implementation of this client side service discovery , we need to configure a Eureka Server & in that Eureka server we need to register the 
      microservices as the Eureka client . This way Eureka server will know the application name , port and IP address of the microservices
      When a client will ask for a certain microservice then it will be given the requested info
      
      Step 1: Configuration of the Eureka Server :
              Eureka service is nothing but a separate microservice which acts as a Eureka Server. 
              To make a microservice act as a eureka server , we need to do some changes :
                  @ Add Eureka server dependencies at the time of project creation , add eureka server starter
                  @ Enable Application to act as Eureka Server i.e @EurekaServer annotation over the main class 
                  @ Configure the port of Eureka Server in application.properties file , configure the port for this Eureka Server
                  @ Default port for Eureka Server is 8761
                  @ Check Eureka Server on browser by calling localhost:8761. this is the default UI page which shows all the registered Eureka clients &
                    other statistics
                  Note: Since Eureka Server is itself a microservice , hence along with other microservices it tries to register itself as Eureka client to 
                        self server. It is okay in multi Eureka Server environment but in case of single Eureka Server , we need to disable it by adding 
                        eureka.client.register-with-eureka = false & eureka.client.fetch-registry = false in application.properties
                        
      Step 2 : Configure microservices as Eureka client :
               To serve as a client each microservice must include Eureka client dependencies.
               @ Add Eureka client in pom.xml or add during the project creation
               @ Provide Spring cloud version as a property
               @ Configure Eureka server connection details . In case of multiple Eureka servers we need to provide the details of the Eureka server to
                 which this Eureka client will register to in application.properties 
               @ Enable the @RestTemplate or WebClient for server discovery . Add the @Loadbalanced annotation over the RestTemplate Bean (on method)
                 so that the RestTemplate will resolve the application name and call the microservices accordingly
               @ Eureka Server does the basic load balancing using the round robin pattern
               @ Replace the IP address & port number of microservice by application name in calling microservice
                  for example: restTemplate.getForObject("http://localhost:8080/home", Student.class); will become as below
                               restTemplate.getForObject("http://student-application/home", Student.class);
                               
               Note: In this way Eureka Server helps in service discovery and that is also in a load balanced way. Although adding Eureka client starter
                     auto configures the service as client but some time we need to add the annotations over the main class as @EnableEurekaClient
                     
               Note : To add multiple eureka servers to the client to make it more fault tolerant you need to add the server in appcation.properties
                      urls of the eureka servers separated by comma
                     
------------------------------------------------------------------------------------------------------------------------------------------------------------

66. What if multiple microservices are registered under the same name or what if multiple instances of same microservice is registered to Eureka-Server
    (ofcourse on different ports or machine) how to do basic load balancing ?
Ans: Basic load balancing is done by eureka server itelf at the client side

------------------------------------------------------------------------------------------------------------------------------------------------------------

67. How fault tolerance works or How eureka server knows a fault in a service or how to detect a service is down after registery ?
Ans: Eureka server itself keeps watch over all the registered microservices by pinging them on a regular interval (a simple sol run multiple instance)

------------------------------------------------------------------------------------------------------------------------------------------------------------

68. What is a fault tolerance ?
Ans : The property of a microservice application that how much it is tolerant for a specific fault is known as fault tolerance

------------------------------------------------------------------------------------------------------------------------------------------------------------

69. @value("${key}")
    private String value;
    
------------------------------------------------------------------------------------------------------------------------------------------------------------
    
70. What can be done to make the application fault tolerant at basic level or without using any library ?
Ans @ We can run multiple instances of the microservice to work even when an instance is down
    @ We can add timeout in resttemplates so that the slowness of one service doesn't effect the others
    
------------------------------------------------------------------------------------------------------------------------------------------------------------
    
71 What is fallback mechanism ?
Ans : fallback is the alternative mechanism when there is a fault in the microservice or when a microservice is down
      Different ways of implementing fallback:
      @Throw an error
      @Return default fallback response
      @Use cache and return response from the previous data
      
------------------------------------------------------------------------------------------------------------------------------------------------------------

71. What is circuit breaking in programming ?
Ans: Circuit Breaking is all about managing the failures in a graceful -fault tolerant manner which prevents failure cascading and gives a default
     behaviour when the service fails
     
------------------------------------------------------------------------------------------------------------------------------------------------------------

72.  Hystrix What is this ?
Ans: Hystrix a Netflix's open source library which follows the circuit breaker pattern.
               It allows us to introduce the fault tolerant and latency tolerance by isolating failures and by preventing them from cascading.
               In this way it helps us to build a robust distributed system
               
               Implementing the Hystrix circuit breaker pattern :
               Step 1:
               @Add the hystrix dependency in the pom.xml
               @Add @Enable circuit breaker in the main application class
               @Add @HystrixCommand(fallBackMthod = "xyz") annotation to the method that needs circuit breaker. where xyz is the fallback method where
                    the control would go in case of failure events
               
               Step 2: Configure Hystrix behaviour
               @ Fallback method must have the same parameter list as the method on which the request actually failed also return type
               @ Fallback method must be in the same class
               @ Fallback must return proxy data or false data or data which doesn't require further API calling
               @ Below @HystrixCommand multiple @HytrixProperty can be defined like timeout time, Error threshold percentage
 
------------------------------------------------------------------------------------------------------------------------------------------------------------
               
73.  Hystrix dashboard ?
Ans: Hystrix also provides the feature to display all the added circuit breakers in the API in a visual way. For this you just 
     need to add the Spring-cloud-hystrix-dashboard dependencies
     Note : It shows all the data like how many ciruit breakers are there and which one is active and how much processing time it is taking

------------------------------------------------------------------------------------------------------------------------------------------------------------
     
74. What is API gateway ?
Ans: API gateway is like front door for all our requests made from different services
     Advantages :
     @ It provides a single entry point for the complete application
     @ Automatically locates the requested resource (by connecting the discovery server)
     @ By hiding resource location and providing only one entry point it provides security
     @ They come with multiple monitoring and analytical tools which helps in application health analysis
   
------------------------------------------------------------------------------------------------------------------------------------------------------------
  
     
75. What is Spring Cloud Gateway ?
Ans: Step 1:
      @ Make a new project and add the spring-cloud-starter-gateway dependency
      @ Also add the eureka client dependency : spring-cloud-starter-netflix-eureka-client
      
      Step 2:
      @ Add @EnableEurekaClient on the main application class
      @ Add the configuration in YAML file for the patterns of the microsevices that it needs to look into eureka server
     
------------------------------------------------------------------------------------------------------------------------------------------------------------

76. JSP lifecycle ?
Ans: JSP -> translation into Servlet -> compilation of the servlet code -> initialization by using the init method -> then finally service methods are called

------------------------------------------------------------------------------------------------------------------------------------------------------------

77. Marker interface examples ?
Ans: Serializable, Cloneable

------------------------------------------------------------------------------------------------------------------------------------------------------------

78. Functional Interface examples ?
Ans: Comparable, Comparator

------------------------------------------------------------------------------------------------------------------------------------------------------------

79. What is Factory design pattern ?
Ans: Just define one interface or abstract class and let the child class to decide the way of instantiation & initiation

------------------------------------------------------------------------------------------------------------------------------------------------------------

80. Different types of approches to create a singleton class ?
Ans: Eager Initialization , Static Block Initialization, Lazy Initialization, Thread Safe Singleton, Thread Safe using double check locking

------------------------------------------------------------------------------------------------------------------------------------------------------------


81. How can singleton pattern be destroyed and how to prevent it ?
Ans: It can be destroyed through Reflection , Serialization , Cloning
     * Prevention from reflection : use enum singleton pattern
     * From serialization : override read resolve method in your singleton class to return the same object
     * From Cloning : 
                  * When singleton class implements cloneable interface: Override the clone method to either throw clone not supported exception
                    explicitly or return the value from getinstancemethod
                  * When singleton class hasn't implemented the cloneable interface but has extended a class which has extended cloneable interface:
                    In this case through inheritance singleton class can also be cloned but solution is same i.e. override clone method in singleton class
                    
------------------------------------------------------------------------------------------------------------------------------------------------------------
                    
82. What is the default autowiring type in @autowired ?
Ans: by type

------------------------------------------------------------------------------------------------------------------------------------------------------------

83. What is cloning ?
Ans: To make anyclass eligible for cloning it much implement the cloneable interface & override the clone method, 
     else it will throw clone not supported exception
     Ways to do cloning:
     * Shallow cloning : In this only the primitive types are copied however if there is any refence type say address in Student the clone 
                         also starts pointing to the refenrnce address thereby creating a problem
     * Deep cloning : 
     
			@Override
			public Object clone() {
			    User user = null;
			    try {
			        user = (User) super.clone();
			    } catch (CloneNotSupportedException e) {
			        user = new User(
			          this.getFirstName(), this.getLastName(), this.getAddress());
			    }
			    user.address = (Address) this.address.clone();
			    return user;
			}
	
------------------------------------------------------------------------------------------------------------------------------------------------------------
			
84.What is serialization ?
Ans: Serialization is the process of writing the state of an object into a byte stream
     Note: Serialization and Deserialization are platform independent process which means we can serialize on one platform and desizalise on other
     
------------------------------------------------------------------------------------------------------------------------------------------------------------
     
85. Important points related to serialization 
Ans: * This process is platform independent
     * Static and transient variables are not serialized
     * Constructor of a class never called during serialization to create the objects
     * Only those classes which have implemented the serializable interface can be serialized
     * If parent class has implemented the serializable interface then child can be serialized but vice-versa is not true
     * Serialization can break the singleton pattern , so to avoid this class must override the readResolve method

------------------------------------------------------------------------------------------------------------------------------------------------------------

86. Hibernate interview questions ?
Ans: https://www.java67.com/2016/02/top-20-hibernate-interview-questions.html

------------------------------------------------------------------------------------------------------------------------------------------------------------

87. Difference betweeen first level and second level cache ?
Ans: *The primary difference is that the first level cache is maintained at the Session level 
       while the second level cache is maintained at the SessionFactory level.
     *The data stored in the first level cache is accessible to the only Session who maintains it, while the second level cache is accessible to all.
     *The first level cache is by default enabled while the second level cache is by default disabled

------------------------------------------------------------------------------------------------------------------------------------------------------------

88. Difference between save and persist in hibernate ?
Ans: https://stackoverflow.com/questions/5862680/whats-the-difference-between-session-persist-and-session-save-in-hibernate   

------------------------------------------------------------------------------------------------------------------------------------------------------------
       
89. Syntaxs ?
Ans:  @GetMapping("/testBookingFeedback/{id}")
      public ResponseEntity getTestBookingDetails(@PathVariable("id") int id)
      
      @PostMapping("/testBookingFeedback")
      public ResponseEntity addTestResult(@RequestBody TestFeedback testFeedback){
    
      @PutMapping("/heavyresource/{id}")
      public ResponseEntity<?> saveResource(@RequestBody HeavyResource heavyResource, @PathVariable("id") String id))
      
      @PatchMapping("/heavyresource/{id}")
      public ResponseEntity<?> partialUpdateName(@RequestBody HeavyResourceAddressOnly partialUpdate, @PathVariable("id") String id)

      @RequestMapping(value = "/heavyresource/{id}", method = RequestMethod.PATCH, consumes = MediaType.APPLICATION_JSON_VALUE)
      public ResponseEntity<?> partialUpdateGeneric(@RequestBody Map<String, Object> updates, @PathVariable("id") String id)
      
      @DeleteMapping("/courses/{courseId}")
      public List<Course> deleteCourse(@PathVariable String courseId)

------------------------------------------------------------------------------------------------------------------------------------------------------------

90. Stateful and stateless protocol ?
Ans: HTTP --> stateless --> it doesnt't require to store the session information for multiple requests
     FTP, Telnet --> stateful

------------------------------------------------------------------------------------------------------------------------------------------------------------

91. Static code analysis ?
Ans: SonarQube
     Link: https://www.baeldung.com/sonar-qube
     Link: https://www.c-sharpcorner.com/article/step-by-step-sonarqube-setup-and-run-sonarqube-scanner/
     
     Add the file --> sonar-project.properties in the project:
     sonar.projectKey="any unique name"
     sonar.projectName="any unique name"
     sonar.sourceEncoding=UTF-8
     sonar.sources="list of folders which will scan"
     sonar.exclusion="list of folders which will exclude from scan"

------------------------------------------------------------------------------------------------------------------------------------------------------------



























3. Third party garbage collectors
4. PermGen space (where classes are stored) is 64MB on Sun JVMs.
5. metaspace in java 8
6. Using a solution like AppDynamics you can easily monitor the different memory pool sizes over time to understand just 
   how close your application is exhausting memory so you can better finetune your JVM/CLR memory settings.
   
7.  I see two options, each of them having their pros and cons:
    Install a profiler agent and connect a profiler on your application. This has of course some serious performance impact which may be not acceptable in your production environment. But this would allow you to monitor the application and perform a memory dump when Heap space is almost full.
    Reproduce your production environment elsewhere and also use a profiler. If your issues only appear with big loads, you may have to create load tests so that you reach the OOME.
    Using a profiler is your best chance to find memory leaks.
    Otherwise, you can always try to perform static code reviewing, using PMD and Findbugs (amongst other static analysis tools) which may spot some mistakes.

   
8. For spring boot profiling : During application start we define the environment


