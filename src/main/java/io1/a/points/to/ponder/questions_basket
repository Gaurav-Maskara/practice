
1. Second Level caching in JPA
A: https://www.java67.com/2017/10/difference-between-first-level-and-second-level-cache-in-Hibernate.html























1. Implement a comparator
2. Use executor service for creating thread pool
3. Third party garbage collectors
4. PermGen space (where classes are stored) is 64MB on Sun JVMs.
5. metaspace in java 8
6. Using a solution like AppDynamics you can easily monitor the different memory pool sizes over time to understand just 
   how close your application is exhausting memory so you can better finetune your JVM/CLR memory settings.
   
7.  I see two options, each of them having their pros and cons:
    Install a profiler agent and connect a profiler on your application. This has of course some serious performance impact which may be not acceptable in your production environment. But this would allow you to monitor the application and perform a memory dump when Heap space is almost full.
    Reproduce your production environment elsewhere and also use a profiler. If your issues only appear with big loads, you may have to create load tests so that you reach the OOME.
    Using a profiler is your best chance to find memory leaks.
    Otherwise, you can always try to perform static code reviewing, using PMD and Findbugs (amongst other static analysis tools) which may spot some mistakes.

   
8. For spring boot profiling : During application start we define the environment
9. Singleton design pattern
10. 


