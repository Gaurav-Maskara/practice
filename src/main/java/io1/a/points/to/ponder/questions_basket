
1. How to sort data that can’t fit into main memory?
Ans: User external sorting where data is sorted in chunks and merged back to get the sorted result (External merge sorted is used here)

2. Name some garbage collection algos in java
Ans: 


3. Define factory design pattern
Ans: It says just define the interface or abstract class to decide the way of instantation and initiation

4. Different approaches for creating a singleton clas 
Ans : Eager initialization , static block initialization, lazy initialization, thread safe singleton, thread safe singleton using double check
Note : in eager initialization there is wastage of cpu if object is not required moreover exception handling can't be done
       but exception handling can be done in static block
       
5. How can the singleton pattern be destroyed ?
Ans: 1. By Reflection
     2. By Serialization
     3. By Cloning
     
     1.Prevention from reflection : use enum singleton
     2.From Serialization : override read resolve method in singleton class to return the same object
                          eg. in method --> protected Object readResolve(){ return getInstance()};
     3.From cloning : 
                    When singleton class implements cloneable interface 
                    Ans:Overide the clone method and either return the same object or throw clonenot supported exception
                    When the singleton class doen't implement the cloneable interface but extends a class, which has implemented the cloneable interface
                    Ans : The solution for this would be same as above


6. Cloning ?
Ans: The class should implement the cloneable interface , also it should override the clone method
     #Shallow copy cloning : in clone method return : return super.clone();
     #Deep copy cloning : In this the primitive values as well as object references are also copied to the clone object
                          Do below in clone method:
                               Employee cloned = (Employee)super.clone();
                               cloned.setDepartment((Department)cloned.getDepartment().clone());   
                               return cloned;
                               
                               
7. What are the possible exception in serialization and deserialization ?
Ans: IOException/ FileNotFound/ ClassNotFound/ InvalidClass

8. What is serial version uid ?
Ans: In serialization process , an Id is associated with each serilizable class to verify the object at both sender and receiver side, this id is serial ver uid

9. Define or state effect of different keywords on serialization?
Ans: Final variables: serialized
     transient : not serialized 
     static : not serialized and has the current value of static variable in class memory
     Constructor of class is never called
     If the parent class has implemented the serializable interface then child class can be serialized but vice versa is not true
     
     
10. Enums can be used in place of public static final variables 
    Its a class basically used to declare constants
    
11. What is the difference between get and load methods of hibernate ?
Ans: Both of these methods are same as both are used to fetch the data from the DB
     Differences:
                Get: hits the Db and returns the object if the object is in DB 
                     returns null if the object is not in DB
                     loads the data as soon as method is called
                Load : It throws object not found if the object is not in the DB
     
     
12. What do you mean by persistence context ?
Ans: Loading of object in persistnce context means that the object is 
     



















3. Third party garbage collectors
4. PermGen space (where classes are stored) is 64MB on Sun JVMs.
5. metaspace in java 8
6. Using a solution like AppDynamics you can easily monitor the different memory pool sizes over time to understand just 
   how close your application is exhausting memory so you can better finetune your JVM/CLR memory settings.
   
7.  I see two options, each of them having their pros and cons:
    Install a profiler agent and connect a profiler on your application. This has of course some serious performance impact which may be not acceptable in your production environment. But this would allow you to monitor the application and perform a memory dump when Heap space is almost full.
    Reproduce your production environment elsewhere and also use a profiler. If your issues only appear with big loads, you may have to create load tests so that you reach the OOME.
    Using a profiler is your best chance to find memory leaks.
    Otherwise, you can always try to perform static code reviewing, using PMD and Findbugs (amongst other static analysis tools) which may spot some mistakes.

   
8. For spring boot profiling : During application start we define the environment


